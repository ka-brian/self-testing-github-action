const { Octokit } = require("@octokit/rest");
const core = require("@actions/core");

class GitHubService {
  constructor(config) {
    this.github = new Octokit({ auth: config.githubToken });
    this.owner = config.owner;
    this.repo = config.repo;
    this.prNumber = config.prNumber;
  }

  async getPRContext() {
    const { data: pr } = await this.github.pulls.get({
      owner: this.owner,
      repo: this.repo,
      pull_number: this.prNumber,
    });

    const { data: files } = await this.github.pulls.listFiles({
      owner: this.owner,
      repo: this.repo,
      pull_number: this.prNumber,
    });

    const repoContext = await this.getRepoContext();
    const previewUrls = await this.getPreviewUrls();

    return {
      pr: {
        title: pr.title,
        body: pr.body,
        head: pr.head.sha,
        base: pr.base.sha,
        author: pr.user.login,
      },
      files: files.map((file) => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        patch: file.patch,
      })),
      repoContext,
      previewUrls,
    };
  }

  async getPreviewUrls() {
    try {
      const { data: comments } = await this.github.issues.listComments({
        owner: this.owner,
        repo: this.repo,
        issue_number: this.prNumber,
      });

      const previewUrls = [];

      const patterns = [
        /https:\/\/[a-zA-Z0-9-]+\.vercel\.app/g,
        /https:\/\/[a-zA-Z0-9-]+\.netlify\.app/g,
        /https:\/\/[a-zA-Z0-9-]+\.railway\.app/g,
        /https:\/\/preview-[a-zA-Z0-9-]+\.[a-zA-Z0-9.-]+/g,
      ];

      for (const comment of comments) {
        if (
          comment.user.type === "Bot" &&
          comment.body.includes("Generated by")
        ) {
          continue;
        }

        for (const pattern of patterns) {
          const matches = comment.body.match(pattern);
          if (matches) {
            previewUrls.push(...matches);
          }
        }
      }

      const uniqueUrls = [...new Set(previewUrls)];

      if (uniqueUrls.length > 0) {
        core.info(`üìç Found preview URLs: ${uniqueUrls.join(", ")}`);
      } else {
        core.info("üìç No preview URLs found in PR comments");
      }

      return uniqueUrls;
    } catch (error) {
      core.warning(`Failed to get preview URLs: ${error.message}`);
      return [];
    }
  }

  async waitForPreviewUrls(waitTimeSeconds) {
    const waitTime = waitTimeSeconds * 1000;
    const pollInterval = 10000;
    const startTime = Date.now();

    while (Date.now() - startTime < waitTime) {
      const urls = await this.getPreviewUrls();
      if (urls.length > 0) {
        return urls;
      }

      const elapsed = Math.round((Date.now() - startTime) / 1000);
      core.info(`‚è≥ Still waiting for preview URLs... (${elapsed}s elapsed)`);

      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }

    core.warning(
      "‚ö†Ô∏è Timeout waiting for preview URLs, proceeding without them"
    );
    return [];
  }

  async getRepoContext() {
    const contextFiles = [
      "package.json",
      "README.md",
      "tsconfig.json",
      "next.config.js",
      "vite.config.js",
      "webpack.config.js",
      ".env.example",
    ];

    const context = {};

    for (const filename of contextFiles) {
      try {
        const { data } = await this.github.repos.getContent({
          owner: this.owner,
          repo: this.repo,
          path: filename,
        });

        if (data.content && data.size < 50000) {
          context[filename] = Buffer.from(data.content, "base64").toString(
            "utf8"
          );
        }
      } catch (error) {
        core.debug(`${filename} not found or too large, skipping`);
      }
    }

    return context;
  }

  async createComment(body) {
    await this.github.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber,
      body: body,
    });
  }

  async commentGenerated(testReport) {
    const timestamp = new Date().toISOString();

    const passedCount = testReport.testCases.filter(
      (t) => t.status === "PASSED"
    ).length;
    const failedCount = testReport.testCases.filter(
      (t) => t.status === "FAILED"
    ).length;
    const readyToRunCount = testReport.testCases.filter(
      (t) => t.status === "READY_TO_RUN"
    ).length;
    const generatedCount = testReport.testCases.filter(
      (t) => t.status === "GENERATED"
    ).length;

    const statusIcon = testReport.success ? "‚úÖ" : "‚ùå";
    const overallStatus = testReport.success
      ? testReport.executionSkipped
        ? "TESTS GENERATED"
        : "TESTS EXECUTED"
      : "EXECUTION FAILED";

    const testCasesList = testReport.testCases
      .map((testCase, index) => {
        const statusIcon =
          testCase.status === "PASSED"
            ? "‚úÖ"
            : testCase.status === "FAILED"
            ? "‚ùå"
            : testCase.status === "READY_TO_RUN"
            ? "üöÄ"
            : "üìù";
        return `${statusIcon} **${index + 1}.** ${testCase.name}`;
      })
      .join("\n");

    const comment = `## üß™ Test Execution Report

*Auto-generated tests for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

### Overall Status: ${statusIcon} ${overallStatus}

### Test Summary:
- **Total Test Cases**: ${testReport.testCases.length}
- **Passed**: ‚úÖ ${passedCount}
- **Failed**: ‚ùå ${failedCount}
- **Ready to Run**: üöÄ ${readyToRunCount}
- **Generated**: üìù ${generatedCount}

### Test Cases:
${testCasesList}

${
  testReport.executionSkipped
    ? `### Status:
üöÄ **Tests Generated Successfully** - The test cases above are ready to run. Execution was skipped because test dependencies are not available in this environment.

${testReport.errors ? `**Details**: ${testReport.errors}` : ""}`
    : testReport.errors
    ? `### Error Details:
\`\`\`
${testReport.errors}
\`\`\``
    : ""
}

> **Note**: Tests were automatically generated${
      testReport.executionSkipped ? "" : " and executed"
    } based on the PR changes.

---
<sub>Generated by [PR Test Generator](https://github.com/yourusername/pr-test-generator)</sub>`;

    await this.createComment(comment);
  }

  async commentSkippedTests() {
    const timestamp = new Date().toISOString();

    try {
      await this.createComment(`## ‚ö° UI Tests Skipped

*Auto-generated test analysis for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

### Analysis Result:
‚úÖ **No UI changes detected** - UI tests have been skipped automatically.

### Reasoning:
This PR appears to contain backend/infrastructure changes that don't require UI testing. The changes were analyzed for:
- Frontend file patterns (JS, CSS, HTML, components)
- UI-related keywords in PR description
- UI-related code patterns in patches

### Test Status:
- **UI Tests**: ‚è≠Ô∏è Skipped (not needed)
- **Overall Status**: ‚úÖ Passed

> **Note**: If this PR should have included UI tests, please add UI-related keywords to the PR description or ensure UI files are included in the changes.

---
<sub>Generated by [PR Test Generator](https://github.com/yourusername/pr-test-generator)</sub>`);
    } catch (commentError) {
      core.error(`Failed to comment skipped tests: ${commentError.message}`);
    }
  }

  async commentError(error) {
    try {
      await this.createComment(`## ‚ùå Test Generation Failed

An error occurred while generating tests for PR #${this.prNumber}:

\`\`\`
${error.message}
\`\`\`

This might be due to:
- Repository structure not being recognized
- Claude API rate limits or errors
- Test execution environment issues

Please check the action logs for more details.

---
<sub>Generated by [PR Test Generator](https://github.com/yourusername/pr-test-generator)</sub>`);
    } catch (commentError) {
      core.error(`Failed to comment error: ${commentError.message}`);
    }
  }
}

module.exports = GitHubService;