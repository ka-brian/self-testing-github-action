import { Octokit } from "@octokit/rest";
import * as core from "@actions/core";
import * as crypto from "crypto";

interface Config {
  githubToken: string;
  owner: string;
  repo: string;
  prNumber: number;
}

interface PRFile {
  filename: string;
  status: string;
  additions: number;
  deletions: number;
  patch?: string;
}

interface PR {
  title: string;
  body: string | null;
  head: string;
  base: string;
  author: string;
}

interface PRContext {
  pr: PR;
  files: PRFile[];
  repoContext: Record<string, string>;
  previewUrls: string[];
}

interface TestResult {
  name: string;
  status: "passed" | "failed" | "skipped";
  error?: string;
}

interface TestReport {
  success: boolean;
  executionSkipped?: boolean;
  testResults?: TestResult[];
  errors?: string;
}




class GitHubService {
  private github: Octokit;
  private owner: string;
  private repo: string;
  private prNumber: number;

  constructor(config: Config) {
    this.github = new Octokit({ auth: config.githubToken });
    this.owner = config.owner;
    this.repo = config.repo;
    this.prNumber = config.prNumber;
  }

  async getPRContext(): Promise<PRContext> {
    const { data: pr } = await this.github.pulls.get({
      owner: this.owner,
      repo: this.repo,
      pull_number: this.prNumber,
    });

    const { data: files } = await this.github.pulls.listFiles({
      owner: this.owner,
      repo: this.repo,
      pull_number: this.prNumber,
    });

    const repoContext = await this.getRepoContext();
    const previewUrls = await this.getPreviewUrls();

    return {
      pr: {
        title: pr.title,
        body: pr.body,
        head: pr.head.sha,
        base: pr.base.sha,
        author: pr.user?.login || "",
      },
      files: files.map((file) => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        patch: file.patch,
      })),
      repoContext,
      previewUrls,
    };
  }

  async getPreviewUrls(): Promise<string[]> {
    try {
      const { data: comments } = await this.github.issues.listComments({
        owner: this.owner,
        repo: this.repo,
        issue_number: this.prNumber,
      });

      const previewUrls: string[] = [];

      const patterns = [
        /https:\/\/[a-zA-Z0-9-]+\.vercel\.app/g,
        /https:\/\/[a-zA-Z0-9-]+\.netlify\.app/g,
        /https:\/\/[a-zA-Z0-9-]+\.railway\.app/g,
        /https:\/\/preview-[a-zA-Z0-9-]+\.[a-zA-Z0-9.-]+/g,
      ];

      for (const comment of comments) {
        if (
          comment.user?.type === "Bot" &&
          comment.body &&
          comment.body.includes("Generated by")
        ) {
          continue;
        }

        if (comment.body) {
          for (const pattern of patterns) {
            const matches = comment.body.match(pattern);
            if (matches) {
              previewUrls.push(...matches);
            }
          }
        }
      }

      const uniqueUrls = [...new Set(previewUrls)];

      if (uniqueUrls.length > 0) {
        core.info(`üìç Found preview URLs: ${uniqueUrls.join(", ")}`);
      } else {
        core.info("üìç No preview URLs found in PR comments");
      }

      return uniqueUrls;
    } catch (error) {
      core.warning(`Failed to get preview URLs: ${(error as Error).message}`);
      return [];
    }
  }

  async waitForPreviewUrls(waitTimeSeconds: number): Promise<string[]> {
    const waitTime = waitTimeSeconds * 1000;
    const pollInterval = 10000;
    const startTime = Date.now();

    while (Date.now() - startTime < waitTime) {
      const urls = await this.getPreviewUrls();
      if (urls.length > 0) {
        return urls;
      }

      const elapsed = Math.round((Date.now() - startTime) / 1000);
      core.info(`‚è≥ Still waiting for preview URLs... (${elapsed}s elapsed)`);

      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }

    core.warning(
      "‚ö†Ô∏è Timeout waiting for preview URLs, proceeding without them"
    );
    return [];
  }

  async getRepoContext(): Promise<Record<string, string>> {
    const contextFiles = [
      "package.json",
      "README.md",
      "tsconfig.json",
      "next.config.js",
      "vite.config.js",
      "webpack.config.js",
      ".env.example",
    ];

    const context: Record<string, string> = {};

    for (const filename of contextFiles) {
      try {
        const { data } = await this.github.repos.getContent({
          owner: this.owner,
          repo: this.repo,
          path: filename,
        });

        if ("content" in data && data.content && data.size && data.size < 50000) {
          context[filename] = Buffer.from(data.content, "base64").toString(
            "utf8"
          );
        }
      } catch (error) {
        core.debug(`${filename} not found or too large, skipping`);
      }
    }

    return context;
  }

  async createComment(body: string): Promise<void> {
    await this.github.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber,
      body: body,
    });
  }

  async commentGenerated(testReport: TestReport): Promise<void> {
    const timestamp = new Date().toISOString();

    // Build test results section
    let testResultsSection = "";
    if (testReport.testResults && testReport.testResults.length > 0) {
      testResultsSection = `\n### Test Results:\n`;
      testReport.testResults.forEach((test, index) => {
        const icon =
          test.status === "passed"
            ? "‚úÖ"
            : test.status === "failed"
            ? "‚ùå"
            : "‚ö†Ô∏è";
        testResultsSection += `${index + 1}. ${icon} **${test.name}**`;
        if (test.status === "failed" && test.error) {
          testResultsSection += `\n   - Error: ${test.error}`;
        }
        testResultsSection += "\n";
      });
    }

    const comment = `## üß™ Test Execution Report

*Auto-generated tests for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

${testResultsSection}
${
  testReport.executionSkipped
    ? `### Status:
üöÄ **Tests Executed Successfully**

${testReport.errors ? `**Details**: ${testReport.errors}` : ""}`
    : testReport.errors
    ? `### Error Details:
\`\`\`
${testReport.errors}
\`\`\``
    : ""
}

> **Note**: Tests were automatically generated${
      testReport.executionSkipped ? "" : " and executed"
    } based on the PR changes.

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`;

    await this.createComment(comment);
  }

  async commentSkippedTests(): Promise<void> {
    const timestamp = new Date().toISOString();

    try {
      await this.createComment(`## ‚ö° UI Tests Skipped

*Auto-generated test analysis for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

### Analysis Result:
‚úÖ **No UI changes detected** - UI tests have been skipped automatically.

### Reasoning:
This PR appears to contain backend/infrastructure changes that don't require UI testing. The changes were analyzed for:
- Frontend file patterns (JS, CSS, HTML, components)
- UI-related keywords in PR description
- UI-related code patterns in patches

### Test Status:
- **UI Tests**: ‚è≠Ô∏è Skipped (not needed)
- **Overall Status**: ‚úÖ Passed

> **Note**: If this PR should have included UI tests, please add UI-related keywords to the PR description or ensure UI files are included in the changes.

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`);
    } catch (commentError) {
      core.error(`Failed to comment skipped tests: ${(commentError as Error).message}`);
    }
  }

  async commentSitemapIrrelevant(): Promise<void> {
    const timestamp = new Date().toISOString();
    try {
      await this.createComment(`## üó∫Ô∏è UI Tests Skipped - Outside Sitemap Scope

*Auto-generated test analysis for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

### Analysis Result:
‚ö†Ô∏è **Changes are outside sitemap scope** - UI tests have been skipped to avoid ineffective testing.

### Reasoning:
This PR contains UI changes, but they appear to be in areas not covered by the provided sitemap. Running tests against the sitemap would likely not catch issues in the modified areas.

### What this means:
- The sitemap defines which areas of the application can be effectively tested
- Changes in this PR affect areas outside that scope
- Manual testing may still be valuable for these changes
- Consider updating the sitemap if these areas should be included in future automated testing

### Test Status:
- **UI Tests**: ‚è≠Ô∏è Skipped (outside sitemap scope)
- **Overall Status**: ‚ö†Ô∏è Requires manual review

### Next steps:
- Review if manual testing is needed for the modified areas
- Consider whether the sitemap should be expanded to cover these changes
- If these changes should be testable, update \`sitemap.json\` to include relevant paths

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`);
    } catch (error) {
      core.warning(`Failed to comment on PR: ${(error as Error).message}`);
    }
  }

  async commentError(error: Error): Promise<void> {
    try {
      await this.createComment(`## ‚ùå Test Generation Failed

An error occurred while generating tests for PR #${this.prNumber}:

\`\`\`
${error.message}
\`\`\`

This might be due to:
- Repository structure not being recognized
- Claude API rate limits or errors
- Test execution environment issues

Please check the action logs for more details.

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`);
    } catch (commentError) {
      core.error(`Failed to comment error: ${(commentError as Error).message}`);
    }
  }





}

export default GitHubService;