import { Octokit } from "@octokit/rest";
import * as core from "@actions/core";
import * as crypto from "crypto";

interface Config {
  githubToken: string;
  owner: string;
  repo: string;
  prNumber: number;
}

interface PRFile {
  filename: string;
  status: string;
  additions: number;
  deletions: number;
  patch?: string;
}

interface PR {
  title: string;
  body: string | null;
  head: string;
  base: string;
  author: string;
}

interface PRContext {
  pr: PR;
  files: PRFile[];
  repoContext: Record<string, string>;
  previewUrls: string[];
}

interface TestResult {
  name: string;
  status: "passed" | "failed" | "skipped";
  error?: string;
}

interface TestReport {
  success: boolean;
  executionSkipped?: boolean;
  testResults?: TestResult[];
  errors?: string;
}

interface CacheData {
  testCode: string;
  changesHash: string;
  testPlan: string;
  timestamp: string;
  version: string;
}

interface CredentialPattern {
  pattern: RegExp;
  placeholder: string;
}

interface PlaceholderMapping {
  placeholder: string;
  value: string;
}

class GitHubService {
  private github: Octokit;
  private owner: string;
  private repo: string;
  private prNumber: number;

  constructor(config: Config) {
    this.github = new Octokit({ auth: config.githubToken });
    this.owner = config.owner;
    this.repo = config.repo;
    this.prNumber = config.prNumber;
  }

  async getPRContext(): Promise<PRContext> {
    const { data: pr } = await this.github.pulls.get({
      owner: this.owner,
      repo: this.repo,
      pull_number: this.prNumber,
    });

    const { data: files } = await this.github.pulls.listFiles({
      owner: this.owner,
      repo: this.repo,
      pull_number: this.prNumber,
    });

    const repoContext = await this.getRepoContext();
    const previewUrls = await this.getPreviewUrls();

    return {
      pr: {
        title: pr.title,
        body: pr.body,
        head: pr.head.sha,
        base: pr.base.sha,
        author: pr.user?.login || "",
      },
      files: files.map((file) => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        patch: file.patch,
      })),
      repoContext,
      previewUrls,
    };
  }

  async getPreviewUrls(): Promise<string[]> {
    try {
      const { data: comments } = await this.github.issues.listComments({
        owner: this.owner,
        repo: this.repo,
        issue_number: this.prNumber,
      });

      const previewUrls: string[] = [];

      const patterns = [
        /https:\/\/[a-zA-Z0-9-]+\.vercel\.app/g,
        /https:\/\/[a-zA-Z0-9-]+\.netlify\.app/g,
        /https:\/\/[a-zA-Z0-9-]+\.railway\.app/g,
        /https:\/\/preview-[a-zA-Z0-9-]+\.[a-zA-Z0-9.-]+/g,
      ];

      for (const comment of comments) {
        if (
          comment.user?.type === "Bot" &&
          comment.body &&
          (comment.body.includes("Generated by") ||
           comment.body.includes("TEST_CODE_CACHE"))
        ) {
          continue;
        }

        if (comment.body) {
          for (const pattern of patterns) {
            const matches = comment.body.match(pattern);
            if (matches) {
              previewUrls.push(...matches);
            }
          }
        }
      }

      const uniqueUrls = [...new Set(previewUrls)];

      if (uniqueUrls.length > 0) {
        core.info(`üìç Found preview URLs: ${uniqueUrls.join(", ")}`);
      } else {
        core.info("üìç No preview URLs found in PR comments");
      }

      return uniqueUrls;
    } catch (error) {
      core.warning(`Failed to get preview URLs: ${(error as Error).message}`);
      return [];
    }
  }

  async waitForPreviewUrls(waitTimeSeconds: number): Promise<string[]> {
    const waitTime = waitTimeSeconds * 1000;
    const pollInterval = 10000;
    const startTime = Date.now();

    while (Date.now() - startTime < waitTime) {
      const urls = await this.getPreviewUrls();
      if (urls.length > 0) {
        return urls;
      }

      const elapsed = Math.round((Date.now() - startTime) / 1000);
      core.info(`‚è≥ Still waiting for preview URLs... (${elapsed}s elapsed)`);

      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }

    core.warning(
      "‚ö†Ô∏è Timeout waiting for preview URLs, proceeding without them"
    );
    return [];
  }

  async getRepoContext(): Promise<Record<string, string>> {
    const contextFiles = [
      "package.json",
      "README.md",
      "tsconfig.json",
      "next.config.js",
      "vite.config.js",
      "webpack.config.js",
      ".env.example",
    ];

    const context: Record<string, string> = {};

    for (const filename of contextFiles) {
      try {
        const { data } = await this.github.repos.getContent({
          owner: this.owner,
          repo: this.repo,
          path: filename,
        });

        if ("content" in data && data.content && data.size && data.size < 50000) {
          context[filename] = Buffer.from(data.content, "base64").toString(
            "utf8"
          );
        }
      } catch (error) {
        core.debug(`${filename} not found or too large, skipping`);
      }
    }

    return context;
  }

  async createComment(body: string): Promise<void> {
    await this.github.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber,
      body: body,
    });
  }

  async commentGenerated(testReport: TestReport, usedCache = false): Promise<void> {
    const timestamp = new Date().toISOString();

    // Build test results section
    let testResultsSection = "";
    if (testReport.testResults && testReport.testResults.length > 0) {
      testResultsSection = `\n### Test Results:\n`;
      testReport.testResults.forEach((test, index) => {
        const icon =
          test.status === "passed"
            ? "‚úÖ"
            : test.status === "failed"
            ? "‚ùå"
            : "‚ö†Ô∏è";
        testResultsSection += `${index + 1}. ${icon} **${test.name}**`;
        if (test.status === "failed" && test.error) {
          testResultsSection += `\n   - Error: ${test.error}`;
        }
        testResultsSection += "\n";
      });
    }

    const cacheNotice = usedCache 
      ? "\n> üöÄ **Performance**: Test code was retrieved from cache (no regeneration needed)\n"
      : "";

    const comment = `## üß™ Test Execution Report

*Auto-generated tests for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

${testResultsSection}
${
  testReport.executionSkipped
    ? `### Status:
üöÄ **Tests Executed Successfully**

${testReport.errors ? `**Details**: ${testReport.errors}` : ""}`
    : testReport.errors
    ? `### Error Details:
\`\`\`
${testReport.errors}
\`\`\``
    : ""
}
${cacheNotice}
> **Note**: Tests were automatically generated${
      testReport.executionSkipped ? "" : " and executed"
    } based on the PR changes.

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`;

    await this.createComment(comment);
  }

  async commentSkippedTests(): Promise<void> {
    const timestamp = new Date().toISOString();

    try {
      await this.createComment(`## ‚ö° UI Tests Skipped

*Auto-generated test analysis for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

### Analysis Result:
‚úÖ **No UI changes detected** - UI tests have been skipped automatically.

### Reasoning:
This PR appears to contain backend/infrastructure changes that don't require UI testing. The changes were analyzed for:
- Frontend file patterns (JS, CSS, HTML, components)
- UI-related keywords in PR description
- UI-related code patterns in patches

### Test Status:
- **UI Tests**: ‚è≠Ô∏è Skipped (not needed)
- **Overall Status**: ‚úÖ Passed

> **Note**: If this PR should have included UI tests, please add UI-related keywords to the PR description or ensure UI files are included in the changes.

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`);
    } catch (commentError) {
      core.error(`Failed to comment skipped tests: ${(commentError as Error).message}`);
    }
  }

  async commentSitemapIrrelevant(): Promise<void> {
    const timestamp = new Date().toISOString();
    try {
      await this.createComment(`## üó∫Ô∏è UI Tests Skipped - Outside Sitemap Scope

*Auto-generated test analysis for PR #${this.prNumber} ‚Ä¢ ${timestamp}*

### Analysis Result:
‚ö†Ô∏è **Changes are outside sitemap scope** - UI tests have been skipped to avoid ineffective testing.

### Reasoning:
This PR contains UI changes, but they appear to be in areas not covered by the provided sitemap. Running tests against the sitemap would likely not catch issues in the modified areas.

### What this means:
- The sitemap defines which areas of the application can be effectively tested
- Changes in this PR affect areas outside that scope
- Manual testing may still be valuable for these changes
- Consider updating the sitemap if these areas should be included in future automated testing

### Test Status:
- **UI Tests**: ‚è≠Ô∏è Skipped (outside sitemap scope)
- **Overall Status**: ‚ö†Ô∏è Requires manual review

### Next steps:
- Review if manual testing is needed for the modified areas
- Consider whether the sitemap should be expanded to cover these changes
- If these changes should be testable, update \`sitemap.json\` to include relevant paths

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`);
    } catch (error) {
      core.warning(`Failed to comment on PR: ${(error as Error).message}`);
    }
  }

  async commentError(error: Error): Promise<void> {
    try {
      await this.createComment(`## ‚ùå Test Generation Failed

An error occurred while generating tests for PR #${this.prNumber}:

\`\`\`
${error.message}
\`\`\`

This might be due to:
- Repository structure not being recognized
- Claude API rate limits or errors
- Test execution environment issues

Please check the action logs for more details.

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`);
    } catch (commentError) {
      core.error(`Failed to comment error: ${(commentError as Error).message}`);
    }
  }

  async getCachedTestCode(): Promise<CacheData | null> {
    try {
      const { data: comments } = await this.github.issues.listComments({
        owner: this.owner,
        repo: this.repo,
        issue_number: this.prNumber,
      });

      // Look for the most recent test code cache comment
      for (const comment of comments.reverse()) {
        if (
          comment.user?.login === "github-actions[bot]" &&
          comment.body &&
          comment.body.includes("<!-- TEST_CODE_CACHE_START -->") &&
          comment.body.includes("<!-- TEST_CODE_CACHE_END -->")
        ) {
          // Extract the cached data
          const cacheMatch = comment.body.match(
            /<!-- TEST_CODE_CACHE_START -->([\s\S]*?)<!-- TEST_CODE_CACHE_END -->/
          );
          
          if (cacheMatch && cacheMatch[1]) {
            try {
              const cacheData = JSON.parse(
                Buffer.from(cacheMatch[1].trim(), "base64").toString("utf8")
              ) as CacheData;
              return cacheData;
            } catch (e) {
              core.warning("Failed to parse cached test code");
            }
          }
        }
      }

      return null;
    } catch (error) {
      core.warning(`Failed to get cached test code: ${(error as Error).message}`);
      return null;
    }
  }

  async cacheTestCode(testCode: string, changesHash: string, testPlan: string): Promise<void> {
    try {
      // Replace sensitive credentials with placeholders before caching
      const sanitizedTestCode = this.replaceSensitiveCredentials(testCode);
      
      const cacheData: CacheData = {
        testCode: sanitizedTestCode,
        changesHash,
        testPlan,
        timestamp: new Date().toISOString(),
        version: "1.0",
      };

      const encodedCache = Buffer.from(
        JSON.stringify(cacheData)
      ).toString("base64");

      const comment = `## üóÑÔ∏è Test Code Cache

*Cached test code for PR #${this.prNumber} ‚Ä¢ ${cacheData.timestamp}*

<details>
<summary><b>üìä Cache Details</b> (click to expand)</summary>

### Cache Information:
- **Changes Hash**: \`${changesHash.substring(0, 8)}...\`
- **Cached At**: ${cacheData.timestamp}
- **Version**: ${cacheData.version}
- **Test Plan**: ${testPlan ? 'Included' : 'Not included'}

### Security Notice:
> üîí Sensitive credentials have been replaced with placeholders to prevent exposure in PR comments. They will be automatically restored during test execution.

### Cache Data:
<details>
<summary><i>View raw cache (base64)</i></summary>

<!-- TEST_CODE_CACHE_START -->
${encodedCache}
<!-- TEST_CODE_CACHE_END -->

</details>

</details>

> **Note**: This cache is automatically managed and will be used to speed up subsequent test runs if the PR changes remain similar.

---
<sub>Generated by [PR Test Generator](https://github.com/ka-brian/self-testing-github-action)</sub>`;

      await this.createComment(comment);
      core.info("‚úÖ Test code cached successfully");
    } catch (error) {
      core.warning(`Failed to cache test code: ${(error as Error).message}`);
    }
  }

  calculateChangesHash(prContext: PRContext): string {
    // Create a simple hash of the changed files and their patches
    const hash = crypto.createHash("sha256");

    // Include file names and their patches
    prContext.files.forEach((file) => {
      hash.update(file.filename);
      hash.update(file.status);
      hash.update(String(file.additions));
      hash.update(String(file.deletions));
      if (file.patch) {
        hash.update(file.patch);
      }
    });

    // Include PR title and description
    hash.update(prContext.pr.title);
    hash.update(prContext.pr.body || "");

    return hash.digest("hex").substring(0, 16);
  }

  replaceSensitiveCredentials(testCode: string): string {
    // Define credential patterns and their placeholders
    const credentialPatterns: CredentialPattern[] = [
      {
        // Match process.env.TEST_USER_EMAIL values
        pattern: /process\.env\.TEST_USER_EMAIL/g,
        placeholder: "'{{TEST_USER_EMAIL_PLACEHOLDER}}'"
      },
      {
        // Match process.env.TEST_USER_PASSWORD values
        pattern: /process\.env\.TEST_USER_PASSWORD/g,
        placeholder: "'{{TEST_USER_PASSWORD_PLACEHOLDER}}'"
      },
      {
        // Match hardcoded email patterns in test code
        pattern: /['"]([^'"]+@[^'"]+\.[^'"]+)['"]/g,
        placeholder: "'{{EMAIL_PLACEHOLDER}}'"
      },
      {
        // Match API keys (ANTHROPIC_API_KEY, CLAUDE_API_KEY)
        pattern: /process\.env\.(ANTHROPIC_API_KEY|CLAUDE_API_KEY)/g,
        placeholder: "'{{API_KEY_PLACEHOLDER}}'"
      }
    ];

    let sanitizedCode = testCode;
    
    // Replace each pattern with its placeholder
    credentialPatterns.forEach(({ pattern, placeholder }) => {
      sanitizedCode = sanitizedCode.replace(pattern, placeholder);
    });

    // Log what was replaced for debugging
    if (sanitizedCode !== testCode) {
      core.info("üîí Sensitive credentials replaced with placeholders in cached test code");
    }

    return sanitizedCode;
  }

  restoreSensitiveCredentials(testCode: string): string {
    // Map placeholders back to their actual values
    const placeholderMappings: PlaceholderMapping[] = [
      {
        placeholder: "'{{TEST_USER_EMAIL_PLACEHOLDER}}'",
        value: "process.env.TEST_USER_EMAIL"
      },
      {
        placeholder: "'{{TEST_USER_PASSWORD_PLACEHOLDER}}'",
        value: "process.env.TEST_USER_PASSWORD"
      },
      {
        placeholder: "'{{EMAIL_PLACEHOLDER}}'",
        // If we have TEST_USER_EMAIL in env, use it; otherwise keep placeholder
        value: process.env.TEST_USER_EMAIL ? `'${process.env.TEST_USER_EMAIL}'` : "'{{EMAIL_PLACEHOLDER}}'"
      },
      {
        placeholder: "'{{API_KEY_PLACEHOLDER}}'",
        value: "process.env.ANTHROPIC_API_KEY"
      }
    ];

    let restoredCode = testCode;
    
    // Replace each placeholder with its actual value
    placeholderMappings.forEach(({ placeholder, value }) => {
      restoredCode = restoredCode.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), value);
    });

    // Log restoration for debugging
    if (restoredCode !== testCode) {
      core.info("üîì Restored sensitive credentials from placeholders");
    }

    return restoredCode;
  }
}

export default GitHubService;